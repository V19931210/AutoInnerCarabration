using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Net.Sockets;
using System.Threading;
using System.Net;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.IO;

namespace weldDeviceProduct
{
    public partial class Form1 : Form
    {
        private static readonly Mutex mutex = new Mutex();//多线程情况下保证线程安全

        private Form2 frm2;//参数编辑界面

        //WeldTrack和BCS100
        private Process proWeldTrack;
        private IntPtr weldFormHandle = new IntPtr(0);
        private Process proBCS100;

        public static Socket sensorSocket;
        public static Socket heightSocket;

        public static int id = 1000;//用于给寻缝器发指令的id
        public static JsonSerializerSettings jsonSetting = new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore };//忽略结构体空值字段

        private double optViewDist;//记录最佳视距
        private double actualDist;//记录角点实际宽度
        private double[][] cornerPoints;//记录采集的标定数据
        private bool isCaliing = false;//标记是否处于自动标定过程中
        private bool isGettingHeight = false;//标记是否处于获取调高器高度过程中

        [DllImport("USER32.DLL")]
        public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [DllImport("user32.dll ", EntryPoint = "SetParent")]
        private static extern IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent);   //将外部窗体嵌入程序

        [DllImport("user32.dll", EntryPoint = "ShowWindow", CharSet = CharSet.Auto)]
        private static extern int ShowWindow(IntPtr hwnd, int nCmdShow);                  //设置窗体属性

        [DllImport("user32.dll", EntryPoint = "SetWindowLong", CharSet = CharSet.Auto)]
        public static extern IntPtr SetWindowLong(IntPtr hWnd, int nIndex, long dwNewLong);

        [DllImport("user32.dll", EntryPoint = "GetWindowLong", CharSet = CharSet.Auto)]
        public static extern long GetWindowLong(IntPtr hWnd, int nIndex);

        [DllImport("user32.dll")]

        private static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);

        /// <summary>
        /// 去除窗体边框
        /// </summary>
        /// <param name="vHandle">窗口句柄</param>
        public static void RemoveWindowBorder(IntPtr vHandle)
        {
            const int GWL_STYLE = (-16);
            const int WS_CAPTION = 0xC00000;
            const int WS_BORDER = 0x800000;
            const int WS_THICKFRAME = 0x00040000;
            const int WS_CHILDWINDOW = 0x40000000;

            long LStyle = GetWindowLong(vHandle, GWL_STYLE);

            LStyle = (LStyle & (~WS_CAPTION) & (~WS_BORDER) & (~WS_THICKFRAME)) | WS_CHILDWINDOW;
            SetWindowLong(vHandle, GWL_STYLE, LStyle);
        }

        /// <summary>
        /// 调整第三方应用窗体大小
        /// </summary>
        public void ResizeWindow()
        {
            ShowWindow(weldFormHandle, 0);  //先将窗口隐藏
            ShowWindow(weldFormHandle, 3);  //再将窗口最大化，可以让第三方窗口自适应容器的大小
        }

        void timerUpdateFrm_Tick(object sender, EventArgs e)
        {
            //第三方窗体句柄不为空
            if (weldFormHandle != IntPtr.Zero)
            {
                System.Threading.Thread t = new System.Threading.Thread(ResizeWindow);
                t.Start();  //开线程刷新第三方窗体大小
                System.Threading.Thread.Sleep(50); //略加延时
                timerUpdateFrm.Stop();  //停止定时器
            }
        }

        public Form1()
        {
            InitializeComponent();
            Control.CheckForIllegalCrossThreadCalls = false;

            timerUpdateFrm.Tick += new EventHandler(timerUpdateFrm_Tick);  //绑定事件
            timerUpdateFrm.Interval = 200;

            frm2 = new Form2();

            sensorSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            sensorSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, 2000);

            heightSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            heightSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, 5000);

            cornerPoints = new double[10][];
            for (int i = 0; i < cornerPoints.Length; i++)
            {
                cornerPoints[i] = new double[5];
            }

        }

        private void Form1_Load(object sender, EventArgs e)
        {
            //打开BCVWeldTrack.exe
            Process[] proWeldTrackArr = Process.GetProcessesByName("BCVWeldTrack");
            if (proWeldTrackArr.Length > 0)
            {
                proWeldTrack = proWeldTrackArr[0];
            }
            else
            {
                try
                {
                    proWeldTrack = new Process();
                    proWeldTrack.StartInfo.FileName = "C:\\Program Files (x86)\\Friendess\\BCVWeldTrack\\BCVWeldTrack.exe";
                    proWeldTrack.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
                    proWeldTrack.Start();
                }
                catch (Exception ex)
                {
                    Log.AppendText(System.DateTime.Now + "：启动寻缝器软件失败！\r\n");
                    MessageBox.Show(ex.Message);
                }
            }

            //查找BCVWeldTrack.exe主窗口窗口句柄
            for (int i = 0; i < 30; i++)
            {
                weldFormHandle = FindWindow(null, "BCVWeldTrackMainForm");
                if (weldFormHandle != IntPtr.Zero)
                {
                    //MessageBox.Show("Find BCVWeldTrackMainForm!");
                    break;
                }
                else
                {
                    System.Threading.Thread.Sleep(100);
                }
            }

            if (weldFormHandle == IntPtr.Zero)
            {
                MessageBox.Show("not Find BCVWeldTrackMainForm!");
            }

            RemoveWindowBorder(weldFormHandle);  //移除边框
            SetParent(weldFormHandle, pnlMainFrom.Handle); //嵌入父容器
            ShowWindowAsync(weldFormHandle, 3);   //显示

            //打开BCS100APP.exe
            Process[] proBCS100Arr = Process.GetProcessesByName("BCS100APP");
            if (proBCS100Arr.Length > 0)
            {
                proBCS100 = proBCS100Arr[0];
            }
            else
            {
                try
                {
                    proBCS100 = new Process();
                    proBCS100.StartInfo.FileName = "C:\\Program Files (x86)\\Friendess\\BCVWeldTrack\\BCS100APP.exe";
                    proBCS100.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Normal;
                    proBCS100.Start();
                }
                catch (Exception ex)
                {
                    Log.AppendText(System.DateTime.Now + "：启动调高器测试软件失败！\r\n");
                    MessageBox.Show(ex.Message);
                }
            }

            //连接寻缝器软件
            try
            {
                sensorSocket.Connect(new IPEndPoint(IPAddress.Parse("127.0.0.1"), 5020));
            }
            catch (Exception ex)
            {
                Log.AppendText(System.DateTime.Now + "：连接寻缝器失败！\r\n");
                MessageBox.Show(ex.Message);
            }

            //连接调高器软件
            try
            {
                heightSocket.Connect(new IPEndPoint(IPAddress.Parse("127.0.0.1"), 60001));
            }
            catch (Exception ex)
            {
                Log.AppendText(System.DateTime.Now + "：连接调高器测试软件失败！\r\n");
                MessageBox.Show(ex.Message);
            }

            //打开激光
            openCloseLaser();

            //设置默认激光占空比100%
            cbbLaserHoldSpacePercent.SelectedIndex = 0;
        }

        private void Form1_FormClosed(object sender, FormClosedEventArgs e)
        {
            Thread.Sleep(100);

            //关闭激光
            openCloseLaser();

            sensorSocket.Close();
            heightSocket.Close();

            Process[] proWeldTrackArr = Process.GetProcessesByName("BCVWeldTrack");
            if (proWeldTrackArr.Length > 0)
            {
                proWeldTrackArr[0].Kill();
            }

            Process[] proBCS100Arr = Process.GetProcessesByName("BCS100APP");
            if (proBCS100Arr.Length > 0)
            {
                proBCS100Arr[0].Kill();
            }
        }

        private void pnlMainFrom_SizeChanged(object sender, EventArgs e)
        {
            timerUpdateFrm.Start();
        }

        //给寻缝器发指令
        public static bool sendCmdToSensor(ModelWeldTrack req, ref ModelWeldTrack resp)
        {
            req.Id++;
            string sensor_input = JsonConvert.SerializeObject(req, jsonSetting);
            byte[] sensor_send_buf = Encoding.UTF8.GetBytes(sensor_input + "#Vision");
            sensorSocket.Send(sensor_send_buf);
            //Log.AppendText(sensor_input + "#Vision");

            byte[] sensor_recv_buf = new byte[1024];
            int len = sensorSocket.Receive(sensor_recv_buf);

            if (len > 0)
            {
                string msg = Encoding.UTF8.GetString(sensor_recv_buf);
                string[] jsonStrings = msg.Split('#');
                resp = JsonConvert.DeserializeObject<ModelWeldTrack>(jsonStrings[0]);
                //Log.AppendText(msg);
                return true;
            }

            return false;
        }

        //给调高器发指令
        private static bool sendCmdToHeight(ModelHeightAdjust req, ref ModelHeightAdjust resp)
        {
            string height_input = JsonConvert.SerializeObject(req, jsonSetting);
            byte[] hright_send_buf = Encoding.UTF8.GetBytes(height_input + "#Height");
            heightSocket.Send(hright_send_buf);
            //Log.AppendText(height_input + "#Height");

            byte[] height_recv_buf = new byte[1024];
            int len = heightSocket.Receive(height_recv_buf);

            if (len > 0)
            {
                string msg = Encoding.UTF8.GetString(height_recv_buf);
                string[] jsonStrings = msg.Split('#');
                resp = JsonConvert.DeserializeObject<ModelHeightAdjust>(jsonStrings[0]);
                //Log.AppendText(msg);
                return true;
            }

            return false;
        }

        private void btnOpenCloseLaser_Click(object sender, EventArgs e)
        {
            Thread t = new Thread(openCloseLaser);
            t.IsBackground = true;
            t.Start();
        }

        private void openCloseLaser()
        {
            ModelWeldTrack req = new ModelWeldTrack(WeldTrackCMD.SwitchLaserStatus, id);
            ModelWeldTrack resp = new ModelWeldTrack();
            try
            {
                if (!sendCmdToSensor(req, ref resp))
                {
                    Log.AppendText(System.DateTime.Now + "：未接收到寻缝器返回数据！\r\n");
                    return;
                }

                if (resp.Result != "true")
                {
                    Log.AppendText(System.DateTime.Now + "：发送打开/关闭激光指令失败！\r\n");
                    return;
                }
                else
                {
                    Log.AppendText(System.DateTime.Now + "：发送打开/关闭激光指令成功\r\n");
                }

            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
                return;
            }

        }

        private void cbbLaserHoldSpacePercent_SelectedIndexChanged(object sender, EventArgs e)
        {
            Thread t = new Thread(setLaserHoldSpacePercent);
            t.IsBackground = true;
            t.Start();
        }

        private void setLaserHoldSpacePercent()
        {
            int dutyCycle = Convert.ToInt32(cbbLaserHoldSpacePercent.SelectedItem);
            ModelWeldTrack req = new ModelWeldTrack(WeldTrackCMD.SetLaserDutyCircle, id) { DutyCycle = dutyCycle };
            ModelWeldTrack resp = new ModelWeldTrack();
            try
            {
                if (!sendCmdToSensor(req, ref resp))
                {
                    Log.AppendText(System.DateTime.Now + "：未接收到寻缝器返回数据！\r\n");
                    return;
                }

                if (resp.Result != "true")
                {
                    Log.AppendText(System.DateTime.Now + "：发送设置激光占空比指令失败！\r\n");
                    return;
                }
                else
                {
                    Log.AppendText(System.DateTime.Now + "：发送设置激光占空比指令成功\r\n");
                }

            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
                return;
            }
        }

        private void btnReadOptViewDist_Click(object sender, EventArgs e)
        {
            Thread t = new Thread(readOptViewDist);
            t.IsBackground = true;
            t.Start();
        }

        private void readOptViewDist()
        {
            mutex.WaitOne();
            if (isGettingHeight)
            {
                mutex.ReleaseMutex();
                MessageBox.Show("获取调高器高度正在进行，请勿重复点击！");
                return;
            }
            isGettingHeight = true;
            mutex.ReleaseMutex();

            ModelHeightAdjust req = new ModelHeightAdjust(HeightAdjustState.HeightGet);
            ModelHeightAdjust resp = new ModelHeightAdjust();
            for (int i = 0; i < 5; i++)
            {
                try
                {
                    if (!sendCmdToHeight(req, ref resp))
                    {
                        Log.AppendText(System.DateTime.Now + "：未接收到调高器返回数据！\r\n");
                        break;
                    }

                    if (resp.CMDID == HeightAdjustState.HeightFailedConnect)
                    {
                        Log.AppendText(System.DateTime.Now + "：连接调高器失败！\r\n");
                        break;
                    }
                    else
                    {
                        double H = (double)lineTGQTotalTravel.Value;
                        double h = (double)lineTGQMesaDist.Value;
                        lineOptViewDist.Value = Convert.ToDecimal(H + h - resp.Zpos);
                        break;
                    }
                }
                catch (SocketException ex)
                {
                    if (ex.SocketErrorCode == SocketError.TimedOut)
                    {

                        Log.AppendText(System.DateTime.Now + "：第" + (i + 1) + "次获取调高器高度超时!\r\n");
                        Thread.Sleep(500);
                        continue;
                    }
                    else
                    {
                        MessageBox.Show(ex.Message);
                        break;
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.Message);
                    break;
                }
            }

            mutex.WaitOne();
            isGettingHeight = false;
            mutex.ReleaseMutex();

        }

        private void btnReadStartPoint_Click(object sender, EventArgs e)
        {
            Thread t = new Thread(readStartPoint);
            t.IsBackground = true;
            t.Start();
        }

        private void readStartPoint()
        {
            mutex.WaitOne();
            if (isGettingHeight)
            {
                mutex.ReleaseMutex();
                MessageBox.Show("获取调高器高度正在进行，请勿重复点击！");
                return;
            }
            isGettingHeight = true;
            mutex.ReleaseMutex();

            ModelHeightAdjust req = new ModelHeightAdjust(HeightAdjustState.HeightGet);
            ModelHeightAdjust resp = new ModelHeightAdjust();
            for (int i = 0; i < 5; i++)
            {
                try
                {
                    if (!sendCmdToHeight(req, ref resp))
                    {
                        Log.AppendText(System.DateTime.Now + "：未接收到调高器返回数据！\r\n");
                        break;
                    }

                    if (resp.CMDID == HeightAdjustState.HeightFailedConnect)
                    {
                        Log.AppendText(System.DateTime.Now + "：连接调高器失败！\r\n");
                        break;
                    }
                    else
                    {
                        textStartPos.Clear();
                        textStartPos.AppendText(resp.Zpos.ToString());
                        btnReadStartPoint.Enabled = false;
                        btnReadEndPoint.Enabled = true;
                        break;
                    }
                }
                catch (SocketException ex)
                {
                    if (ex.SocketErrorCode == SocketError.TimedOut)
                    {

                        Log.AppendText(System.DateTime.Now + "：第" + (i + 1) + "次获取调高器高度超时!\r\n");
                        Thread.Sleep(500);
                        continue;
                    }
                    else
                    {
                        MessageBox.Show(ex.Message);
                        break;
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.Message);
                    break;
                }
            }

            mutex.WaitOne();
            isGettingHeight = false;
            mutex.ReleaseMutex();

        }

        private void btnReadEndPoint_Click(object sender, EventArgs e)
        {
            Thread t = new Thread(readEndPoint);
            t.IsBackground = true;
            t.Start();
        }

        private void readEndPoint()
        {
            mutex.WaitOne();
            if (isGettingHeight)
            {
                mutex.ReleaseMutex();
                MessageBox.Show("获取调高器高度正在进行，请勿重复点击！");
                return;
            }
            isGettingHeight = true;
            mutex.ReleaseMutex();

            ModelHeightAdjust req = new ModelHeightAdjust(HeightAdjustState.HeightGet);
            ModelHeightAdjust resp = new ModelHeightAdjust();
            for (int i = 0; i < 5; i++)
            {
                try
                {
                    if (!sendCmdToHeight(req, ref resp))
                    {
                        Log.AppendText(System.DateTime.Now + "：未接收到调高器返回数据！\r\n");
                        break;
                    }

                    if (resp.CMDID == HeightAdjustState.HeightFailedConnect)
                    {
                        Log.AppendText(System.DateTime.Now + "：连接调高器失败！\r\n");
                        break;
                    }
                    else
                    {
                        textEndPos.Clear();
                        textEndPos.AppendText(resp.Zpos.ToString());
                        btnReadStartPoint.Enabled = true;
                        btnReadEndPoint.Enabled = false;
                        break;
                    }
                }
                catch (SocketException ex)
                {
                    if (ex.SocketErrorCode == SocketError.TimedOut)
                    {

                        Log.AppendText(System.DateTime.Now + "：第" + (i + 1) + "次获取调高器高度超时!\r\n");
                        Thread.Sleep(500);
                        continue;
                    }
                    else
                    {
                        MessageBox.Show(ex.Message);
                        break;
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.Message);
                    break;
                }
            }

            mutex.WaitOne();
            isGettingHeight = false;
            mutex.ReleaseMutex();

        }

        private void btnAutoInterParaCali_Click(object sender, EventArgs e)
        {
            Thread t = new Thread(autoInterParaCali);
            t.IsBackground = true;
            t.Start();
        }

        private void autoInterParaCali()
        {
            //验证全局参数合法性
            if (!isParaAllRight())
            {
                return;
            }

            //计算调高器步进距离
            double endPos = Convert.ToDouble(textEndPos.Text.ToString());
            double startPos = Convert.ToDouble(textStartPos.Text.ToString());
            double stepDist = (endPos - startPos) / 9;

            mutex.WaitOne();
            if (isCaliing)
            {
                mutex.ReleaseMutex();
                MessageBox.Show("自动标定正在进行，请勿重复点击！");
                return;
            }
            isCaliing = true;
            textShowIsCaliing.Clear();
            textShowIsCaliing.AppendText("正在自动标定中...");
            mutex.ReleaseMutex();

            Log.AppendText(System.DateTime.Now + "：开始自动标定\r\n");

            //获取10组数据
            int cnt = 10;
            bool isCaliDone = true;//10组标定过程是否全部完成
            ModelHeightAdjust prevZ = new ModelHeightAdjust() { Zpos = -10000 };
            while (isCaliing && cnt-- > 0)
            {
                //控制调高器移动到cornerPoint[cnt]
                cornerPoints[cnt][0] = endPos - stepDist * (9 - cnt);
                ModelHeightAdjust move_req = new ModelHeightAdjust(HeightAdjustState.HeightMove, cornerPoints[cnt][0]);
                ModelHeightAdjust move_resp = new ModelHeightAdjust();
                if (!sendCmdToHeight(move_req, ref move_resp))
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定未接收到调高器数据，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }
                if (move_resp.CMDID == HeightAdjustState.HeightFailedConnect)
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定连接调高器失败，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }

                //稍许等待让调高器运动
                Thread.Sleep(200);

                ModelHeightAdjust get_req = new ModelHeightAdjust(HeightAdjustState.HeightGet);
                ModelHeightAdjust curZ = new ModelHeightAdjust();
                if (!sendCmdToHeight(get_req, ref curZ))
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定未接收到调高器数据，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }
                if (curZ.CMDID == HeightAdjustState.HeightFailedConnect)
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定连接调高器失败，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }

                //判断调高器是否到达指定位置或一直到不了指定位置
                while (Math.Abs(curZ.Zpos - cornerPoints[cnt][0]) > 0.06)
                {
                    Thread.Sleep(200);
                    if (!sendCmdToHeight(get_req, ref curZ))
                    {
                        Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定未接收到调高器数据，标定终止！\r\n");
                        isCaliDone = false;
                        break;
                    }
                    if (curZ.CMDID == HeightAdjustState.HeightFailedConnect)
                    {
                        Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定连接调高器失败，标定终止！\r\n");
                        isCaliDone = false;
                        break;
                    }
                    if (Math.Abs(curZ.Zpos - prevZ.Zpos) < 0.05)
                    {
                        Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定调高器无法运动到指定位置，标定终止！\r\n");
                        isCaliDone = false;
                        break;
                    }
                    prevZ.Zpos = curZ.Zpos;
                }

                if (!isCaliDone)
                {
                    break;
                }

                //调高器运动到位之后等待1.75s再取角点
                Thread.Sleep(1750);

                //获取寻缝器角点数据
                bool isGetPoint = false;
                ModelWeldTrack req = new ModelWeldTrack(WeldTrackCMD.GetCurCoordinate, id);
                ModelWeldTrack resp_left = new ModelWeldTrack();
                ModelWeldTrack resp_right = new ModelWeldTrack();
                //获取失败自动重试5次
                for (int j = 0; isCaliing && j < 5; j++)
                {
                    try
                    {
                        if (!sendCmdToSensor(req, ref resp_left))
                        {
                            Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定未接收到寻缝器数据，标定终止！\r\n");
                            isCaliDone = false;
                            break;
                        }

                        if (resp_left.Result == "true")
                        {
                            isGetPoint = true;
                            break;
                        }
                        else
                        {
                            Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定第" + (j + 1) + "次未捕获到角点数据\r\n");
                            Thread.Sleep(1000);
                            continue;
                        }
                    }
                    catch (SocketException ex)
                    {
                        if (ex.SocketErrorCode == SocketError.TimedOut)
                        {

                            Log.AppendText(System.DateTime.Now + "：第" + (j + 1) + "次获取角点超时!\r\n");
                            Thread.Sleep(500);
                            continue;
                        }
                        else
                        {
                            MessageBox.Show(ex.Message);
                            break;
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show(ex.Message);
                        break;
                    }
                }

                if (!isGetPoint)
                {
                    isCaliDone = false;
                    break;
                }
                //保存该组数据
                cornerPoints[cnt][1] = (double)resp_left.X;
                cornerPoints[cnt][2] = (double)resp_left.Y;

                Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组数据获取成功！\r\n");
                Log.AppendText("调高器高度：" + cornerPoints[cnt][0]
                    + "\r\n角点1X坐标：" + cornerPoints[cnt][1] + "\r\n角点1Y坐标：" + cornerPoints[cnt][2]
                    + "\r\n角点2X坐标：" + cornerPoints[cnt][3] + "\r\n角点2Y坐标：" + cornerPoints[cnt][4] + "\r\n");
            }

            if (isCaliing && isCaliDone)
            {
                optViewDist = Convert.ToDouble(lineOptViewDist.Text);
                actualDist = Convert.ToDouble(lineActualDist.Text);
                Log.AppendText(System.DateTime.Now + "：自动标定完成！\r\n");
            }

            mutex.WaitOne();
            isCaliing = false;
            textShowIsCaliing.Clear();
            textShowIsCaliing.AppendText("标定结束");
            mutex.ReleaseMutex();
        }

        private bool isParaAllRight()
        {
            if (lineOptViewDist.Text == "" || lineActualDist.Text == "")
            {
                Log.AppendText(System.DateTime.Now + "：未输入最佳视距或角点实际宽度！\r\n");
                return false;
            }
            else
            {
                if (lineOptViewDist.Value.Equals(0) || lineActualDist.Value.Equals(0))
                {
                    Log.AppendText(System.DateTime.Now + "：最佳视距和角点实际宽度必须大于0！\r\n");
                    return false;
                }
            }
            if (String.IsNullOrEmpty(textEndPos.Text) || String.IsNullOrEmpty(textStartPos.Text))
            {
                Log.AppendText(System.DateTime.Now + "：未输入调高器起始点或终止点！\r\n");
                return false;
            }
            return true;
        }

        private void btnAutoInterParaCali1_Click(object sender, EventArgs e)
        {
            Thread t = new Thread(autoInterParaCali1);
            t.IsBackground = true;
            t.Start();
        }

        private void autoInterParaCali1()
        {
            //验证全局参数合法性
            if (!isParaAllRight())
            {
                return;
            }

            //计算调高器步进距离
            double endPos = Convert.ToDouble(textEndPos.Text.ToString());
            double startPos = Convert.ToDouble(textStartPos.Text.ToString());
            double stepDist = (endPos - startPos) / 9;

            mutex.WaitOne();
            if (isCaliing)
            {
                mutex.ReleaseMutex();
                MessageBox.Show("自动标定正在进行，请勿重复点击！");
                return;
            }
            isCaliing = true;
            textShowIsCaliing.Clear();
            textShowIsCaliing.AppendText("正在自动标定中...");
            mutex.ReleaseMutex();

            Log.AppendText(System.DateTime.Now + "：开始自动标定第一步\r\n");

            //获取10组数据
            int cnt = 10;
            bool isCaliDone = true;//10组标定过程是否全部完成
            ModelHeightAdjust prevZ = new ModelHeightAdjust() { Zpos = -10000 };
            while (isCaliing && cnt-- > 0)
            {
                //控制调高器移动到cornerPoint[cnt]
                cornerPoints[cnt][0] = endPos - stepDist * (9 - cnt);
                ModelHeightAdjust move_req = new ModelHeightAdjust(HeightAdjustState.HeightMove, cornerPoints[cnt][0]);
                ModelHeightAdjust move_resp = new ModelHeightAdjust();
                if (!sendCmdToHeight(move_req, ref move_resp))
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定未接收到调高器数据，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }
                if (move_resp.CMDID == HeightAdjustState.HeightFailedConnect)
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定连接调高器失败，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }

                //稍许等待让调高器运动
                Thread.Sleep(200);

                ModelHeightAdjust get_req = new ModelHeightAdjust(HeightAdjustState.HeightGet);
                ModelHeightAdjust curZ = new ModelHeightAdjust();
                if (!sendCmdToHeight(get_req, ref curZ))
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定未接收到调高器数据，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }
                if (curZ.CMDID == HeightAdjustState.HeightFailedConnect)
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定连接调高器失败，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }

                //判断调高器是否到达指定位置或一直到不了指定位置
                while (Math.Abs(curZ.Zpos - cornerPoints[cnt][0]) > 0.06)
                {
                    Thread.Sleep(200);
                    if (!sendCmdToHeight(get_req, ref curZ))
                    {
                        Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定未接收到调高器数据，标定终止！\r\n");
                        isCaliDone = false;
                        break;
                    }
                    if (curZ.CMDID == HeightAdjustState.HeightFailedConnect)
                    {
                        Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定连接调高器失败，标定终止！\r\n");
                        isCaliDone = false;
                        break;
                    }
                    if (Math.Abs(curZ.Zpos - prevZ.Zpos) < 0.05)
                    {
                        Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定调高器无法运动到指定位置，标定终止！\r\n");
                        isCaliDone = false;
                        break;
                    }
                    prevZ.Zpos = curZ.Zpos;
                }

                if (!isCaliDone)
                {
                    break;
                }

                //调高器运动到位之后等待1.75s再取角点
                Thread.Sleep(1750);

                //获取寻缝器角点数据
                bool isGetPoint = false;
                ModelWeldTrack req = new ModelWeldTrack(WeldTrackCMD.GetCurCoordinate, id);
                ModelWeldTrack resp = new ModelWeldTrack();
                //获取失败自动重试5次
                for (int j = 0; isCaliing && j < 5; j++)
                {
                    try
                    {
                        if (!sendCmdToSensor(req, ref resp))
                        {
                            Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定未接收到寻缝器数据，标定终止！\r\n");
                            isCaliDone = false;
                            break;
                        }

                        if (resp.Result == "true")
                        {
                            isGetPoint = true;
                            break;
                        }
                        else
                        {
                            Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组标定第" + (j + 1) + "次未捕获到角点数据\r\n");
                            Thread.Sleep(1000);
                            continue;
                        }
                    }
                    catch (SocketException ex)
                    {
                        if (ex.SocketErrorCode == SocketError.TimedOut)
                        {

                            Log.AppendText(System.DateTime.Now + "：第" + (j + 1) + "次获取角点超时!\r\n");
                            Thread.Sleep(500);
                            continue;
                        }
                        else
                        {
                            MessageBox.Show(ex.Message);
                            break;
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show(ex.Message);
                        break;
                    }
                }

                if (!isGetPoint)
                {
                    isCaliDone = false;
                    break;
                }
                //保存该组数据
                cornerPoints[cnt][1] = (double)resp.X;
                cornerPoints[cnt][2] = (double)resp.Y;

                Log.AppendText(System.DateTime.Now + "：第" + (10 - cnt) + "组数据获取成功！\r\n");
                Log.AppendText("调高器高度：" + cornerPoints[cnt][0]
                    + "\r\n角点1X坐标：" + cornerPoints[cnt][1] + "\r\n角点1Y坐标：" + cornerPoints[cnt][2]
                    + "\r\n角点2X坐标：" + cornerPoints[cnt][3] + "\r\n角点2Y坐标：" + cornerPoints[cnt][4] + "\r\n");
            }

            if (isCaliing && isCaliDone)
            {
                optViewDist = Convert.ToDouble(lineOptViewDist.Text);
                actualDist = Convert.ToDouble(lineActualDist.Text);
                Log.AppendText(System.DateTime.Now + "：自动标定第一步完成，设置另一侧检测区域后进行自动标定第二步！\r\n");
                btnAutoInterParaCali2.Enabled = true;
            }

            mutex.WaitOne();
            isCaliing = false;
            textShowIsCaliing.Clear();
            textShowIsCaliing.AppendText("标定结束");
            mutex.ReleaseMutex();
        }

        private void btnAutoInterParaCali2_Click(object sender, EventArgs e)
        {
            Thread t = new Thread(autoInterParaCali2);
            t.IsBackground = true;
            t.Start();
        }

        private void autoInterParaCali2()
        {
            mutex.WaitOne();
            if (isCaliing)
            {
                mutex.ReleaseMutex();
                MessageBox.Show("自动标定正在进行，请勿重复点击！");
                return;
            }
            isCaliing = true;
            textShowIsCaliing.Clear();
            textShowIsCaliing.AppendText("正在自动标定中...");
            mutex.ReleaseMutex();

            Log.AppendText(System.DateTime.Now + "：开始自动标定第二步\r\n");

            bool isCaliDone = true;//10组标定过程是否全部完成
            ModelHeightAdjust prevZ = new ModelHeightAdjust() { Zpos = -10000 };
            for (int i = 0; isCaliing && i < cornerPoints.Length; i++)
            {
                //控制调高器移动到cornerPoints[i][0]
                ModelHeightAdjust move_req = new ModelHeightAdjust(HeightAdjustState.HeightMove, cornerPoints[i][0]);
                ModelHeightAdjust move_resp = new ModelHeightAdjust();
                if (!sendCmdToHeight(move_req, ref move_resp))
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - i) + "组标定未接收到调高器数据，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }
                if (move_resp.CMDID == HeightAdjustState.HeightFailedConnect)
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - i) + "组标定连接调高器失败，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }

                //稍许等待让调高器运动
                Thread.Sleep(200);

                ModelHeightAdjust get_req = new ModelHeightAdjust(HeightAdjustState.HeightGet);
                ModelHeightAdjust curZ = new ModelHeightAdjust();
                if (!sendCmdToHeight(get_req, ref curZ))
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - i) + "组标定未接收到调高器数据，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }
                if (curZ.CMDID == HeightAdjustState.HeightFailedConnect)
                {
                    Log.AppendText(System.DateTime.Now + "：第" + (10 - i) + "组标定连接调高器失败，标定终止！\r\n");
                    isCaliDone = false;
                    break;
                }

                //判断调高器是否到达指定位置或一直到不了指定位置
                while (Math.Abs(curZ.Zpos - cornerPoints[i][0]) > 0.06)
                {
                    Thread.Sleep(200);
                    if (!sendCmdToHeight(get_req, ref curZ))
                    {
                        Log.AppendText(System.DateTime.Now + "：第" + (10 - i) + "组标定未接收到调高器数据，标定终止！\r\n");
                        isCaliDone = false;
                        break;
                    }
                    if (curZ.CMDID == HeightAdjustState.HeightFailedConnect)
                    {
                        Log.AppendText(System.DateTime.Now + "：第" + (10 - i) + "组标定连接调高器失败，标定终止！\r\n");
                        isCaliDone = false;
                        break;
                    }
                    if (Math.Abs(curZ.Zpos - prevZ.Zpos) < 0.05)
                    {
                        Log.AppendText(System.DateTime.Now + "：第" + (10 - i) + "组标定调高器无法运动到指定位置，标定终止！\r\n");
                        isCaliDone = false;
                        break;
                    }
                    prevZ.Zpos = curZ.Zpos;
                }

                if (!isCaliDone)
                {
                    break;
                }

                //调高器运动到位之后等待1.75s再取角点
                Thread.Sleep(1750);

                //获取寻缝器角点数据
                bool isGetPoint = false;
                ModelWeldTrack req = new ModelWeldTrack(WeldTrackCMD.GetCurCoordinate, id);
                ModelWeldTrack resp = new ModelWeldTrack();
                //获取失败自动重试5次
                for (int j = 0; isCaliing && j < 5; j++)
                {
                    try
                    {
                        if (!sendCmdToSensor(req, ref resp))
                        {
                            Log.AppendText(System.DateTime.Now + "：第" + (10 - i) + "组标定未接收到寻缝器数据，标定终止！\r\n");
                            isCaliDone = false;
                            break;
                        }

                        if (resp.Result == "true")
                        {
                            isGetPoint = true;
                            break;
                        }
                        else
                        {
                            Log.AppendText(System.DateTime.Now + "：第" + (10 - i) + "组标定第" + (j + 1) + "次未捕获到角点数据\r\n");
                            Thread.Sleep(1000);
                            continue;
                        }
                    }
                    catch (SocketException ex)
                    {
                        if (ex.SocketErrorCode == SocketError.TimedOut)
                        {

                            Log.AppendText(System.DateTime.Now + "：第" + (j + 1) + "次获取角点超时!\r\n");
                            Thread.Sleep(500);
                            continue;
                        }
                        else
                        {
                            MessageBox.Show(ex.Message);
                            break;
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show(ex.Message);
                        break;
                    }
                }

                if (!isGetPoint)
                {
                    isCaliDone = false;
                    break;
                }
                //保存该组数据
                cornerPoints[i][3] = (double)resp.X;
                cornerPoints[i][4] = (double)resp.Y;
                Log.AppendText(System.DateTime.Now + "：第" + (10 - i) + "组数据获取成功！\r\n");
                Log.AppendText("调高器高度：" + cornerPoints[i][0]
                    + "\r\n角点1X坐标：" + cornerPoints[i][1] + "\r\n角点1Y坐标：" + cornerPoints[i][2]
                    + "\r\n角点2X坐标：" + cornerPoints[i][3] + "\r\n角点2Y坐标：" + cornerPoints[i][4] + "\r\n");
            }

            if (isCaliing && isCaliDone)
            {
                Log.AppendText(System.DateTime.Now + "：自动标定第二步完成\r\n");
            }

            btnAutoInterParaCali2.Enabled = false;

            mutex.WaitOne();
            isCaliing = false;
            textShowIsCaliing.Clear();
            textShowIsCaliing.AppendText("标定结束");
            mutex.ReleaseMutex();
        }

        private void btnStopCaliing_Click(object sender, EventArgs e)
        {
            mutex.WaitOne();
            if (isCaliing)
            {
                isCaliing = false;
                textShowIsCaliing.Clear();
                textShowIsCaliing.AppendText("正在终止标定...");
            }
            mutex.ReleaseMutex();
        }

        private void btnCalMat_Click(object sender, EventArgs e)
        {
            Thread t = new Thread(calMat);
            t.IsBackground = true;
            t.Start();
        }

        private void calMat()
        {
            //格式化指令为string字符串
            string sensor_send_str = "{\"Cmd\":12";
            sensor_send_str += ",\"Id\":" + Convert.ToString(id++);
            sensor_send_str += ",\"DataCnt\":10,\"MidZ\":" + Convert.ToString(optViewDist);
            for (int i = 0; i < cornerPoints.Length; i++)
            {
                sensor_send_str += ",\"LX" + i + "\":" + cornerPoints[i][1].ToString("0.00");
                sensor_send_str += ",\"LY" + i + "\":" + cornerPoints[i][2].ToString("0.00");
                sensor_send_str += ",\"RX" + i + "\":" + cornerPoints[i][3].ToString("0.00");
                sensor_send_str += ",\"RY" + i + "\":" + cornerPoints[i][4].ToString("0.00");
                sensor_send_str += ",\"Height" + i + "\":" + cornerPoints[i][0].ToString("0.00");
                sensor_send_str += ",\"Width" + i + "\":" + actualDist;
            }
            sensor_send_str += "}";

            ModelWeldTrack resp = new ModelWeldTrack();
            try
            {
                if (!sendCalMatToSensor(sensor_send_str, ref resp))
                {
                    Log.AppendText(System.DateTime.Now + "：未接收到寻缝器返回数据！\r\n");
                    return;
                }

                if (resp.Result != "true")
                {
                    Log.AppendText(System.DateTime.Now + "：计算内参矩阵失败！\r\n");
                    return;
                }
                else
                {
                    Log.AppendText(System.DateTime.Now + "：计算内参成功，并已写入寻缝器\r\n");

                    Log.AppendText("MinZ: " + resp.MinZ + "\r\n");
                    Log.AppendText("MidZ: " + resp.MidZ + "\r\n");
                    Log.AppendText("MaxZ: " + resp.MaxZ + "\r\n");
                    Log.AppendText("MinView: " + resp.MinView + "\r\n");
                    Log.AppendText("MidView: " + resp.MidView + "\r\n");
                    Log.AppendText("MaxView: " + resp.MaxView + "\r\n");

                    //更新设备参数编辑界面
                    frm2.UpdateDevicePara(resp);
                }

            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
                return;
            }
        }

        private bool sendCalMatToSensor(string cmd, ref ModelWeldTrack resp)
        {
            //计算内参矩阵的指令发送格式不统一 单独用该函数处理
            byte[] sensor_send_buf = Encoding.UTF8.GetBytes(cmd + "#Vision");
            sensorSocket.Send(sensor_send_buf);
            //Log.AppendText(sensor_input + "#Vision");

            byte[] sensor_recv_buf = new byte[1024];
            int len = sensorSocket.Receive(sensor_recv_buf);

            if (len > 0)
            {
                string msg = Encoding.UTF8.GetString(sensor_recv_buf);
                string[] jsonStrings = msg.Split('#');
                resp = JsonConvert.DeserializeObject<ModelWeldTrack>(jsonStrings[0]);
                //Log.AppendText(msg);
                return true;
            }

            return false;
        }

        private void btnParaEdit_Click(object sender, EventArgs e)
        {
            frm2.ShowDialog();
        }

        private void btnClearLog_Click(object sender, EventArgs e)
        {
            Log.Clear();
        }

        //以下为控制控件行为的委托函数 弃用

        /*        delegate void dgAddStr(string str);
                private void LogAddStr(string str)
                {
                    if (Log.InvokeRequired)
                    {
                        dgAddStr dg = new dgAddStr(LogAddStr);
                        Log.Invoke(dg, str);
                    }
                    else
                    {
                        Log.AppendText(str);
                    }
                }

                private void OptViewDistAddStr(string str)
                {
                    if (lineOptViewDist.InvokeRequired)
                    {
                        dgAddStr dg = new dgAddStr(OptViewDistAddStr);
                        lineOptViewDist.Invoke(dg, str);
                    }
                    else
                    {
                        lineOptViewDist.Value = Convert.ToDecimal(str);
                    }
                }

                private void startPosAddStr(string str)
                {
                    if (textStartPos.InvokeRequired)
                    {
                        dgAddStr dg = new dgAddStr(startPosAddStr);
                        textStartPos.Invoke(dg, str);
                    }
                    else
                    {
                        textStartPos.Clear();
                        textStartPos.AppendText(str);
                    }
                }

                private void endPosAddStr(string str)
                {
                    if (textEndPos.InvokeRequired)
                    {
                        dgAddStr dg = new dgAddStr(endPosAddStr);
                        textEndPos.Invoke(dg, str);
                    }
                    else
                    {
                        textEndPos.Clear();
                        textEndPos.AppendText(str);
                    }
                }

                private void textShowIsCaliingAddStr(string str)
                {
                    if (textShowIsCaliing.InvokeRequired)
                    {
                        dgAddStr dg = new dgAddStr(textShowIsCaliingAddStr);
                        textShowIsCaliing.Invoke(dg, str);
                    }
                    else
                    {
                        textShowIsCaliing.Clear();
                        textShowIsCaliing.AppendText(str);
                    }
                }

                delegate void dgIsEnable();

                private void btnReadStartPointEnable()
                {
                    if (btnReadStartPoint.InvokeRequired)
                    {
                        dgIsEnable dg = new dgIsEnable(btnReadStartPointEnable);
                        btnReadStartPoint.Invoke(dg);
                    }
                    else
                    {
                        btnReadStartPoint.Enabled = true;
                    }
                }

                private void btnReadStartPointDisable()
                {
                    if (btnReadStartPoint.InvokeRequired)
                    {
                        dgIsEnable dg = new dgIsEnable(btnReadStartPointDisable);
                        btnReadStartPoint.Invoke(dg);
                    }
                    else
                    {
                        btnReadStartPoint.Enabled = false;
                    }
                }

                private void btnReadEndPointEnable()
                {
                    if (btnReadEndPoint.InvokeRequired)
                    {
                        dgIsEnable dg = new dgIsEnable(btnReadEndPointEnable);
                        btnReadEndPoint.Invoke(dg);
                    }
                    else
                    {
                        btnReadEndPoint.Enabled = true;
                    }
                }

                private void btnReadEndPointDisable()
                {
                    if (btnReadEndPoint.InvokeRequired)
                    {
                        dgIsEnable dg = new dgIsEnable(btnReadEndPointDisable);
                        btnReadEndPoint.Invoke(dg);
                    }
                    else
                    {
                        btnReadEndPoint.Enabled = false;
                    }
                }

                private void btnAutoInterParaCali1Enable()
                {
                    if (btnAutoInterParaCali1.InvokeRequired)
                    {
                        dgIsEnable dg = new dgIsEnable(btnAutoInterParaCali1Enable);
                        btnAutoInterParaCali1.Invoke(dg);
                    }
                    else
                    {
                        btnAutoInterParaCali1.Enabled = true;
                    }
                }

                private void btnAutoInterParaCali2Enable()
                {
                    if (btnAutoInterParaCali2.InvokeRequired)
                    {
                        dgIsEnable dg = new dgIsEnable(btnAutoInterParaCali2Enable);
                        btnAutoInterParaCali2.Invoke(dg);
                    }
                    else
                    {
                        btnAutoInterParaCali2.Enabled = true;
                    }
                }

                private void btnAutoInterParaCali1Disable()
                {
                    if (btnAutoInterParaCali1.InvokeRequired)
                    {
                        dgIsEnable dg = new dgIsEnable(btnAutoInterParaCali1Disable);
                        btnAutoInterParaCali1.Invoke(dg);
                    }
                    else
                    {
                        btnAutoInterParaCali1.Enabled = false;
                    }
                }

                private void btnAutoInterParaCali2Disable()
                {
                    if (btnAutoInterParaCali2.InvokeRequired)
                    {
                        dgIsEnable dg = new dgIsEnable(btnAutoInterParaCali2Disable);
                        btnAutoInterParaCali2.Invoke(dg);
                    }
                    else
                    {
                        btnAutoInterParaCali2.Enabled = false;
                    }
                }*/

    }
}
